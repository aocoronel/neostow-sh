#!/usr/bin/env sh

NEOSTOW_FILE="$PWD/.neostow"
DIR=$(dirname "$NEOSTOW_FILE")
MODE="create"

COLOR_YELLOW="$(tput setaf 226)"
COLOR_RED="$(tput setaf 196)"
COLOR_GREEN="$(tput setaf 82)"
COLOR_BLUE="$(tput setaf 87)"
COLOR_RESET=$(tput sgr0)

version() {
  printf "1.0.0"
}

help() {
  cat <<EOF
neostow | the declarative GNU stow

Usage:  neostow [OPTIONS] <COMMAND>

Commands:
  delete
          Delete symlinks
  edit
          Edit the neostow file

Options:
  -D, --debug
          Enables debug verbosity
  -F, --force
          Skip prompt dialogs
  -V, --verbose
          Enable verbosity
  -d, --dry
          Describe potential operations
  -f, --file <FILE>
          Load an alternative neostow file
  -h, --help
          Displays this message and exits
  -o, --overwrite
          Overwrite existing symlinks
  -v, --version
          Displays program version
EOF
}

printfc() {
  mode=$1
  case $mode in
  "ERROR" | "FATAL")
    color="$COLOR_RED"
    ;;
  "WARN")
    color="$COLOR_YELLOW"
    ;;
  "DEBUG")
    color="$COLOR_BLUE"
    ;;
  "INFO")
    color="$COLOR_GREEN"
    ;;
  esac
  text=$2
  printf "%s[%s]:%s %s\n" "${color}" "${mode}" "${COLOR_RESET}" "${text}"
}

create_links() {
  src=$1
  dst=$2
  file=$3

  [ "$dst" = "$src" ] && return 1

  message="create"
  ln_flag="--symbolic"

  [ -n "$VERBOSE" ] && ln_flag="$ln_flag --verbose"
  [ "$MODE" = "overwrite" ] && ln_flag="$ln_flag --force"

  case "$MODE" in
  delete)
    message="delete"
    [ "$dst/$file" = "/" ] && {
      printfc "FATAL" "cannot symlink to root directory"
      exit 1
    }
    if [ -n "$DRY_MODE" ]; then
      echo "rm $file"
      return 0
    fi
    [ -n "$VERBOSE" ] && rm -v "$file" && return 0
    [ -z "$VERBOSE" ] && rm "$file" 2>/dev/null && return 0
    ;;
  *)
    #shellcheck disable=SC2086
    if [ -n "$DRY_MODE" ]; then
      echo "$src > $file"
      return 0
    fi
    [ -n "$VERBOSE" ] && ln $ln_flag "$src" "$file" && return 0
    [ -z "$VERBOSE" ] && ln $ln_flag "$src" "$file" 2>/dev/null && return 0
    ;;
  esac
}

read_config() {
  read_line="$1"

  case "$read_line" in
  \#*) return 0 ;;
  *\#*) read_line="${read_line%%#*}" ;;
  esac

  case "$read_line" in
  *'||'* | *'&&'* | *';'* | *'<'* | *'>'* | *'|'*) return 1 ;;
  esac

  if ! echo "$read_line" | grep -q "="; then
    return 1
  fi

  SOURCE_FILE="$(echo "$read_line" | awk -F '=' '{print $1}')"
  [ -n "$DEBUG_MODE" ] && printfc DEBUG "@eval SOURCE_FILE=$DIR/$SOURCE_FILE"
  eval SOURCE_FILE="$DIR/$SOURCE_FILE"
  [ -n "$DEBUG_MODE" ] && {
    printfc "DEBUG" "Source file: $SOURCE_FILE"
  }

  [ ! -f "$SOURCE_FILE" ] && [ ! -d "$SOURCE_FILE" ] && {
    [ -n "$VERBOSE" ] && {
      echo "Source file/directory $SOURCE_FILE does not exist."
    }
    return 1
  }

  [ -n "$DEBUG_MODE" ] && printfc DEBUG "@eval DEST_FOLDER=$DEST_FOLDER"
  DEST_FOLDER=$(echo "$read_line" | awk -F '=' '{print $2}')
  eval DEST_FOLDER="$DEST_FOLDER"
  [ -z "$DEST_FOLDER" ] && return 1
  [ -n "$DEBUG_MODE" ] && {
    printfc "DEBUG" "Destination: $DEST_FOLDER"
  }

  FILEPATH="$DEST_FOLDER/$(basename "$SOURCE_FILE")"
  if [ ! -L "$FILEPATH" ]; then
    diff --report-identical-files -u "$FILEPATH" "$SOURCE_FILE"
    [ "$MODE" == "overwrite" ] && msg="Overwrite"
    [ "$MODE" == "delete" ] && msg="Delete"
    printf "%s %s %s %s" "$FILEPATH" "exists and is not a symlink." "$msg" "? (y/N): " >/dev/tty
    while true; do
      read -r choice </dev/tty
      case "$choice" in
      [yY])
        break
        ;;
      [nN])
        return 0
        ;;
      esac
    done
  fi

  case "$DEST_FOLDER" in
  */) mkdir -p "$DEST_FOLDER" ;;
  esac

  if ! create_links "$SOURCE_FILE" "$DEST_FOLDER" "$FILEPATH"; then
    printfc "ERROR" "failed to ${message} symlink for $(basename "$SOURCE_FILE")"
  fi
}

main() {
  cat "$NEOSTOW_FILE" | while IFS= read -r line; do
    read_config "$line"
  done
}

while getopts ":h-Ddof:Vv" opt; do
  case "$opt" in
  d)
    DRY_MODE=true
    ;;
  D)
    DEBUG_MODE=true
    ;;
  o)
    MODE=overwrite
    ;;
  h)
    help
    exit 0
    ;;
  -)
    break
    ;;
  f)
    NEOSTOW_FILE="$OPTARG"
    ;;
  V)
    VERBOSE=true
    ;;
  v)
    version
    exit 0
    ;;
  ?)
    echo "ERROR: Invalid option '-$OPTARG'" >&2
    exit 1
    ;;
  esac
done

shift $((OPTIND - 1))

case "$1" in
delete)
  MODE=delete
  ;;
edit)
  [ -z "$EDITOR" ] && EDITOR=vim
  $EDITOR "$NEOSTOW_FILE"
  exit 0
  ;;
--help)
  help
  exit 0
  ;;
--debug)
  DEBUG_MODE=true
  ;;
--overwrite)
  MODE=overwrite
  ;;
--file)
  NEOSTOW_FILE="$OPTARG"
  ;;
--verbose)
  VERBOSE=true
  ;;
--dry)
  DRY_MODE=true
  ;;
--version)
  version
  exit 0
  ;;
esac

[ ! -f "$NEOSTOW_FILE" ] && {
  printfc ERROR "$NEOSTOW_FILE not found"
  exit 1
}

STATE_FILE=~/.local/state/neostow-sh
if [ ! -f "$STATE_FILE" ]; then
  mkdir -p "$(dirname "$STATE_FILE")"
  touch "$STATE_FILE"
  printfc WARN "neostow-sh does not have robust shell injection protections!"
  printfc WARN "Do never run this without reviewing the neostow file!"
  printfc WARN "Do use sudo with caution!"
fi

main
